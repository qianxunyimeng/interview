# 算法与数据结构

## 冒泡排序

```js
function bubbleSort(arr) {

    if (!Array.isArray(arr)) {
        return;
    }

    let sortedFlag = true;     //是否是已经有序
    for (let i = 0; i < arr.length - 1; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[i]) {
                let temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;

                sortedFlag = false;
            }
        }

        // 优化：如果是本身就是有序的，那么就不需要再继续循环了。
        if (sortedFlag) {
            break;
        }
    }
}
```

性能

时间复杂度 最坏的情况：O（n^2）
空间复杂度 O（1）

## 选择排序

选择排序原理就是每次从未排序序列中选择最小元素，放到已排序序列的末尾。
那么如何选择最小元素，并把最小元素放到已排序序列的末尾？
只需要遍历寻找最小的数，并保存最小数的索引。遍历完之后，让最小数和已排序序列的末尾互换位置即可。

```js
function selectSort(arr) {
  const len = arr.length;
  let minIndex;   // 保存最小数的索引

  for (let i = 0; i < len - 1; i++) {   // 排好前n-1个，第n个数就是剩下的最大的。
    // 默认为有序
    let hasSort = true;
    minIndex = i;     // 设置最小数的索引的默认值

    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        // 遍历的数比之前村的最小数还小，更改最小数的索引位置
        minIndex = j;
      }
    }

    // 让最小数和已排序序列的末尾互换位置
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];

    // 当是有序数列时，跳出外层循环，减少循环趟
    if (hasSort) {
        break;
    }

  }

  return arr;
}
```

性能
时间复杂度：O(n²)
排序稳定性：不稳定

### 为什莫选择排序说不稳定

让最小数和已排序序列的末尾互换位置时，可能把大小相同的数中在前面的移动到了后面去。

## 快速排序

基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。

方法一:

```js
function quickSort( arr ) {
    if(arr.length <= 1) return arr;
    const num = arr[0];
    let left = [], right = [];
    for(let i = 1;i < arr.length; i++) {
        if(arr[i]<=num) left.push(arr[i]);
        else right.push(arr[i]);
    }
    return quickSort(left).concat([num],quickSort(right));
}

// 优化版 随机基准
function quickSort(arr) {
  if (arr.length <= 1) {
    // 递归退出条件
    return arr;
  }

  // 随机取基准索引
  const pivotIndex = Math.floor(Math.random() * (arr.length - 1));

  // 基准值
  const pivot = arr.splice(pivotIndex, 1)[0];

  const left = [];
  const right = [];

  for (const item of arr) {
    if (item < pivot) {
      // 小于基准值的放在基准值左边
      left.push(item);
    } else {
      right.push(item);
    }
  }

  // 递归+concat实现子数组排序
  return quickSort(left).concat(pivot, quickSort(right));
}

```

传统方法:

java实现

```java
public static void quickSort(int [] a,int left,int right){
        //快速排序算法   
        //找一个基准元素,把数组分为两个部分,前面一部分比基准元素小  后面一部分比基准元素大 保证前面一部分的元素都小于后面一部分的元素
        //一般以第一个元素作为基准元素
        //找两个助手 ,低助手和高助手  ,分别位于数组的两端
        //低助手从左往右找比基准元素大的元素 找到则交换 记录该位置 找不到的话 低助手索引加1
        //高助手从右往前找比基准元素小的元素，找到则交换 ，记录该位置，找不到的话，低助手索引减1
        //直到低助手和高助手重叠 ,则记录该位置   ,数组就被分成了两个部分 再对这两部分进行递归,再分成两部分  最后合即为排好序的数组

        if(left==right){
            return;
        }
        int partition=partition(a,left,right);
        //递归
        quickSort(a,left,partition);
        quickSort(a,partition+1,right);

    }  
    /**
     * 找中间位置的方法
     * @param a 待排序数组
     * @param left ：低助手   低助手从左往右找比基准元素大的元素 找到则交换 记录该位置 找不到的话 低助手索引加1
     * @param right: 高助手  高助手从右往前找比基准元素小的元素，找到则交换 ，记录该位置，找不到的话，低助手索引减1
     */
    public static int partition(int [] a,int left,int right){
        int base=a[left];
        //找两个助手 ,低助手和高助手  ,分别位于数组的两端
        left--;
        right++;
        while(left<right){
            left++;
            while(a[left]<base){
                left++;
            }
            right--;
            while(a[right]>base){
                right--;
            }

            if(left<right){
                swap(a,left,right);
            }
        }
        return right;
    }
    //交换值的函数
    public static  void swap(int [] a,int i,int j){
        int temp;
        temp=a[i];
        a[i]=a[j];
        a[j]=temp;
    }

```

## 插入排序

插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。

```js
function insertion(array) {
  if (!checkArray(array)) return
  for (let i = 1; i < array.length; i++) {
    for (let j = i - 1; j >= 0 && array[j] > array[j + 1]; j--)
      swap(array, j, j + 1);
  }
  return array;
}
```
