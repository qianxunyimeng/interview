# 实战演练

## 去除字符串中最后一个指定的字符(字符串)

```js
// 正则
function delLast(str,target) {
  let reg =new RegExp(`${target}(?=([^${target}]*)$)`)
  return str.replace(reg,'')
}
console.log(delLast('abcdef', 'b')); // acdef
console.log(delLast('abcdefabcd', 'a')); // abcdefbcd
console.log(delLast('abcdefabcd', 'abc')); // abcdefd
console.log(delLast('好好学习,天天向上,学习使我快乐', '学习'));// 好好学习,天天向上,使我快乐
```

```js
// 字符串截取,
function removeLastOccurrence(str, target) {
  return str.substring(0, str.lastIndexOf(target)) + str.substring(str.lastIndexOf(target) + target.length)
}
console.log(delLast('abcdefabcd', 'a')); // abcdefbcd
console.log(delLast('abcdefabcd', 'abc')); // abcdefd
console.log(delLast('好好学习,天天向上,学习使我快乐', '学习'));// 好好学习,天天向上,使我快乐
```

## 下划线命名转驼峰命名

一般使用小驼峰命名法

```js
/**
 * 下划线命名转大驼峰命名
    UnderScoreToCamel('sql_fun_input') ==> SqlFunInput
 *
 */
function UnderScoreToUpperCamel (name) { 
  return name.replace(/(^|_)(\w)/g, (m, $1, $2) => {
    return $2.toUpperCase()
  });
}
console.log(UnderScoreToUpperCamel('sql_fun_input')); //SqlFunInput

/**
 * 下划线命名转小驼峰命名
 */
function UnderScoreToLowerCamel (name) { 
  return name.replace(/_(\w)/g, (m, $1) => {
    return $1.toUpperCase()
  });
}
console.log(UnderScoreToLowerCamel('sql_fun_input')); //sqlFunInput
```

## 驼峰命名转下划线命名

```js
function toUnderline (str) {
  return str.replace(/([A-Z])/g, '_$1').toLowerCase();
}

console.log(toUnderline('systemUsername')); // 输出 'system_username'
console.log(toUnderline('myCode')); // 输出 'my_code'
```

## 大写转小写，小写转大写

```js
function caseConvert(str){
    return str.replace(/([a-z]*)([A-Z]*)/g, (m, s1, s2)=>{
     return `${s1.toUpperCase()}${s2.toLowerCase()}`
    })
}
// caseConvert('AsA33322A2aa') //aSa33322a2AA
```

## 统计某一字符或字符串在另一个字符串中出现的次数

```js
function repeat(str,parentStr){
  return parentStr.split(str).length - 1
}
// repeat('sql','sql908jjksql') => 2

function count(str, param) {
  const reg = new RegExp(param, 'g');
  return str.match(reg).length;
}
// count('sql12390desql','sql')  => 2
```

## js实现一个简单的字符串加密解密的方法
  
```js
// 加密
function strEncrypt(str) {
  var sault = 3;
  return str
    .split("")
    .map(c => {
      return String.fromCharCode(c.charCodeAt(0) + sault);
    })
    .join("");
}
// 解密
function strDecrypt(str) {
  var sault = 3;
  return str
    .split("")
    .map(c => {
      return String.fromCharCode(c.charCodeAt(0) - sault);
    })
    .join("");
}

var str = "hello, world";
console.log(strEncrypt(str)); // khoor/#zruog
console.log(strDecrypt(strEncrypt(str)));// hello, world

```

## 写一个判断数据类型的方法

```js
function myType(v){
    return Object.prototype.toString.call(v).replace(/^.{8}(.+)]$/,(m,$1)=> $1.toLowerCase());
}
console.log(myType('123')) // string
console.log(myType(123)) // number
console.log(myType(true)) // boolean
console.log(myType([])) // array
console.log(myType(() => {})) // function
console.log(myType(new Date())) // date
console.log(myType(new RegExp())) // regexp
```

## 写一个查询url参数的方法

```js
function urlParam(){
    const param = {};
    location.search.replace(/([^&=?]+)=([^&]+)/g,(m,$1,$2)=> param[$1] = $2);
    return param;
}

function getUrlParams (url) {
    const paramsRegex = /[?&]+([^=&]+)=([^&]*)/gi;
    const params = {};
    let match;
    while (match = paramsRegex.exec(url)) {
      params[match[1]] = match[2];
    }
    return params;
}
```

## 通用的函数柯里化工具函数

```js
// 创建一个可以多步执行的柯里化函数，当参数满足数量时就去执行它：
// 函数有一个length参数，表示形参数量，利用length判断当前记录参数数量是否到达或超过形参数量，超过则执行，否则继续返回curry化函数
// 函数公式：fn(x,y,z,w) ==> fn(x)(y)(z)(w);
let createCurry = (fn, ...params) => {
  let args = params || [];
  let fnLen = fn.length; // 指定柯里化函数的参数长度
  if (fnLen === args.length) { 
    //如果第一次参数数量以经足够时就直接调用函数获取结果
    return fn.apply(this, args);
  }
  return (...res) => {
    // 通过作用域链获取上一次的所有参数
    let allArgs = args.slice(0);
    // 深度拷贝闭包共用的args参数，避免后续操作影响（引用类型）
    allArgs.push(...res);
    if (allArgs.length < fnLen) {
      // 当参数数量小于原函数的参数长度时，递归调用createCurry函数
      return createCurry.call(this, fn, ...allArgs);
    } else {
      // 当参数数量满足时，触发函数执行
      return fn.apply(this, allArgs);
    }
  }
}


// 多个参数的普通函数
function add (a, b, c, d) {
  return a + b + c + d;
}
// 测试柯里化函数
console.log(createCurry(add, 1)(2, 3)(4)); // 10
console.log(createCurry(add, 1)(2)(3)(4)); // 10

```

可控制的执行时间的柯里化函数
我们这里直接说明一下函数公式：

- fn(a,b,c) ==> fn(a)(b)(c )();
- fn(a,b,c) ==> fn(a);fn(b);fn(c );fn();
- 当我们参数足够时它并不会执行，只有我们再次调用一次函数它才会执行并返回结果。在这里我们在以上例子中加一个小小的条件就可以实现。

```js
// 当参数满足，再次执行时调用函数
let createCurry = (fn,...params)=> {
 let args = parsms || [];
 let fnLen = fn.length; // 指定柯里化函数的参数长度
 //当然这里的判断需要注释掉，不然当它第一次参数数量足够时就直接执行结果了
 //if(length === _args.length){
    // 加入判断，如果第一次参数数量以经足够时就直接调用函数获取结果
           //return fn.apply(this,args);
        //}
 return (...res)=> {
  let allArgs = args.slice(0);

  allArgs.push(...res);
  // 在这里判断输入的参数是否大于0，如果大于0在判断参数数量是否足够，
  // 这里不能用 && ，如果用&& 也是参数数量足够时就执行结果了。
  if(res.length > 0 || allArgs.length < fnLen){
     return createCurry.call(this,fn,...allArgs);
  }else{
    return fn.apply(this,allArgs);
  }
 }
}

// 多个参数的普通函数
function add(a,b,c,d){
 return a + b + c + d;
}
// 测试可控制的柯里化函数
let curryAdd = createCurry(add,1);
console.log(curryAdd(2)(3)(4)); // function
console.log(curryAdd(2)(3)(4)()); // 10
console.log(curryAdd(2)(3)()); // 当参数不足够时返回 NaN


```

## 函数扁平化

数组扁平化就是将 [1, [2, [3]]] 这种多层的数组拍平成一层 [1, 2, 3]

递归实现

```js
function flatten(arr) {
    var result = []
    for (var i = 0, len = arr.length; i < len; i++{
        if (Array.isArray(arr[i]) {
            result = result.concat(flatten(arr[i]))
        } else {
            result.push(arr[i])
        }
    }
    return result
}

```

es6生成器实现

```js
function* flatten (arr) {
  for (const item of arr) {
    if (Array.isArray(item)) {
      yield* flatten(item)
    } else {
      yield item
    }
  }
}
console.log([...flatten([1,2,[3,4]])]);  // [1,2,3,4]
```

reduce+concat 实现

```js
function flatten(arr) {  
    return arr.reduce((result, item)=> {
        return result.concat(Array.isArray(item) ? flatten(item) : item);
    }, []);
}
const newArr = [...flatten([1, 2, 3, [4, 5, [6]]])]
console.log(newArr) // [1, 2, 3, 4, 5, 6]

```

## 实现es6模版字符串替换的功能

```js
function templateReplace (template, variables) {
  return template.replace(/\{(\w+)\}/g, function (match, key) {
    return variables[key] || match;
  });
}

// 使用示例
const template = 'Hello, {name}! Today is {day}.';
const variables = {
  name: 'Alice',
  day: 'Sunday'
};

const result = templateReplace(template, variables);
console.log(result); // 输出: Hello, Alice! Today is Sunday.

```
